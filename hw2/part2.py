import robby
import numpy as np
from utils import *
# import matplotlib.pyplot as plt
import random
POSSIBLE_ACTIONS = ["MoveNorth", "MoveSouth", "MoveEast", "MoveWest", "StayPut", "PickUpCan", "MoveRandom"]
rw = robby.World(10, 10)
rw.graphicsOff()


def sortByFitness(genomes):
    tuples = [(fitness(g), g) for g in genomes]
    tuples.sort()
    sortedFitnessValues = [f for (f, g) in tuples]
    sortedGenomes = [g for (f, g) in tuples]
    return sortedGenomes, sortedFitnessValues


def randomGenome(length):
    """
    :param length:
    :return: string, random integers between 0 and 6 inclusive
    """
    s = ""
    for i in range(length):
      s = s + str(np.random.randint(7))
    return s


def makePopulation(size, length):
    """
    :param size - of population:
    :param length - of genome
    :return: list of length size containing genomes of length length
    """

    pop = []
    for i in range(size):
      pop.append(randomGenome(length))
    return pop

def fitness(genome, steps=200, init=0.50):
    """

    :param genome: to test
    :param steps: number of steps in the cleaning session
    :param init: amount of cans
    :return:
    """
    total_fitness = 0
    for _ in range(0, 25):
      if type(genome) is not str or len(genome) != 243:
          raise Exception("strategy is not a string of length 243")
      for char in genome:
          if char not in "0123456":
              raise Exception("strategy contains a bad character: '%s'" % char)
      if type(steps) is not int or steps < 1:
          raise Exception("steps must be an integer > 0")
      if type(init) is str:
          # init is a config file
          rw.load(init)
      elif type(init) in [int, float] and 0 <= init <= 1:
          # init is a can density
          rw.goto(0, 0)
          rw.distributeCans(init)
      else:
          raise Exception("invalid initial configuration")
      fit = 0
      for _ in range(len(genome)):
        p = rw.getPerceptCode()
        action = POSSIBLE_ACTIONS[int(genome[p])]
        fit += rw.performAction(action)
      total_fitness += fit
    average_fitness = total_fitness / 25
    return average_fitness

def evaluateFitness(population):
    """
    :param population:
    :return: three values: the average fitness of the population as a whole, the fitness of the best individual
    in the population, the best strategy itself, all of the fitness scores for the population.
    """
    bestFitness = -999999
    bestStrategy = ""
    fitnessess = []
    n = len(population)
    totalFitness = 0
    for i in range(len(population)):
      thisFitness = fitness(population[i])
      fitnessess.append(thisFitness)
      if (thisFitness > bestFitness):
        bestFitness = thisFitness
        bestStrategy = population[i]
      totalFitness += thisFitness
    avg = totalFitness / n
    return (avg, bestFitness, bestStrategy, fitnessess)


def crossover(genome1, genome2):
    """
    :param genome1:
    :param genome2:
    :return: two new genomes produced by crossing over the given genomes at a random crossover point.
    """
    k = np.random.randint(1, len(genome1)-1) # Choose a point that is not the start or end
    c1 = genome2[:k] + genome1[k:]
    c2 = genome1[:k] + genome2[k:]
    return (c1, c2)


def mutate(genome, mutationRate):
    """
    :param genome:
    :param mutationRate:
    :return: a new mutated version of the given genome.
    """
    mutated = ""
    mutation_chance = np.random.uniform(0,1, len(genome))
    for k in range(len(genome)):
      mutate = mutation_chance[k] <= mutationRate
      if mutate:
        mutated = mutated + str(np.random.randint(7))
      else:
        mutated = mutated + genome[k]
    return mutated

def selectPair(sortedPopulation):
    """

    :param sortedPopulation: the population sorted by fitness
    :return: two genomes from the given population using fitness-proportionate selection.
    This function should use RankSelection,
    """
    weights = np.arange(1,len(sortedPopulation)+1)
    return (weightedChoice(sortedPopulation, weights), weightedChoice(sortedPopulation, weights))


def runGA(populationSize, crossoverRate, mutationRate, logFile=""):
    """

    :param populationSize: :param crossoverRate: :param mutationRate: :param logFile: :return: xt file in which to
    store the data generated by the GA, for plotting purposes. When the GA terminates, this function should return
    the generation at which the string of all ones was found.is the main GA program, which takes the population size,
    crossover rate (pc), and mutation rate (pm) as parameters. The optional logFile parameter is a string specifying
    the name of a te
    """
    outFile = open(logFile, 'w+')
    genomeLength = 243
    population = makePopulation(populationSize, genomeLength)
    print("Population size: {}".format(populationSize))
    print("Genome length: {}".format(genomeLength))

    max_iter = 300
    current_iter = 0
    global_max_fitness = -999999

    while (current_iter <= max_iter):
      avgFitness, maxFitness, bestStrategy, fitnessess = evaluateFitness(population)
      if (maxFitness > global_max_fitness): # Keep track of the best strategy
        global_max_fitness = maxFitness
        bestFile = open("results/part2/expirements/bestStrategy.txt", "w+")
        bestFile.write(bestStrategy)
      if (current_iter % 10 == 0): # Output data every ten iterations
        outFile.write("{} {} {} {} \n".format(current_iter, avgFitness, maxFitness, bestStrategy))
        # rw.demo(bestStrategy)
        # rw.graphicsOff()

      print("Generation  {}: average fitness {}, best fitness {}".format(current_iter, avgFitness, maxFitness))
    
      tuples = list(zip(fitnessess, population)) # Zip the fitnesses and population, then sort
      tuples.sort()
      sortedGenomes = [g for (f, g) in tuples] # Extract the sorted population
      
      newPopulation = []
      for _ in range(populationSize): # Build our new population
        parent1, parent2 = selectPair(sortedGenomes)
        perform_crossover = np.random.uniform(0,1) <= crossoverRate
        if perform_crossover:
          child1, child2 = crossover(parent1, parent2)
        else:
          child1, child2 = parent1, parent2
        child1 = mutate(child1, mutationRate)
        child2 = mutate(child2, mutationRate)
        newPopulation.append(child1)
        newPopulation.append(child2)
      population = newPopulation
      current_iter += 1


def test_FitnessFunction():
    f = fitness(rw.strategyM)
    print("Fitness for StrategyM : {0}".format(f))



# test_FitnessFunction()

rw.graphicsOff()
runGA(200, 1.0, 0.005, "results/part2/expirements/GAoutput.txt")


### Plot the results ###

# x = []
# y_avg = []
# y_max = []
# inFile = open("results/part2/expirements/GAoutput.txt")
# line = inFile.readline()
# while line:
#   gen, avg_fitness, max_fitness, _ = line.split()
#   x.append(float(gen))
#   y_avg.append(float(avg_fitness))
#   y_max.append(float(max_fitness))
#   line = inFile.readline()

# fig, ax = plt.subplots()
# ax.plot(x, y_avg, label = "average fitness")
# ax.plot(x, y_max, label = "best fitness")
# ax.set_xlabel("Generation")
# ax.set_ylabel("Fitness")
# ax.set_title("Fitness vs Generation")
# plt.legend()
# plt.show()